%%%%
% Modificación de una plantilla de Latex para adaptarla al castellano.
%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Thin Sectioned Essay
% LaTeX Template
% Version 1.0 (3/8/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original Author:
% Nicolas Diaz (nsdiaz@uc.cl) with extensive modifications by:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper, 11pt]{article} % Font size (can be 10pt, 11pt or 12pt) and paper size (remove a4paper for US letter paper)

\usepackage[protrusion=true,expansion=true]{microtype} % Better typography
\usepackage{graphicx} % Required for including pictures
\usepackage[usenames,dvipsnames]{color} % Coloring code
\usepackage{wrapfig} % Allows in-line images
\usepackage[utf8]{inputenc}

% Imágenes
\usepackage{graphicx} 

\usepackage{amsmath}
% para importar svg
%\usepackage[generate=all]{svgfig}

% sudo apt-get install texlive-lang-spanish
\usepackage[spanish]{babel} % English language/hyphenation
\selectlanguage{spanish}
% Hay que pelearse con babel-spanish para el alineamiento del punto decimal
\decimalpoint
\usepackage{dcolumn}
\newcolumntype{d}[1]{D{.}{\esperiod}{#1}}
\makeatletter
\addto\shorthandsspanish{\let\esperiod\es@period@code}
\makeatother

\usepackage{longtable}
\usepackage{tabu}
\usepackage{supertabular}

\usepackage{multicol}
\newsavebox\ltmcbox

% Para algoritmos
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsthm}
\input{spanishAlgorithmic.tex}

% Para matrices
\usepackage{amsmath}

% Símbolos matemáticos
\usepackage{amssymb}
\let\oldemptyset\emptyset
\let\emptyset\varnothing

\usepackage[section]{placeins} % Para gráficas en su sección.
\usepackage{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Required for accented characters
\newenvironment{allintypewriter}{\ttfamily}{\par}
\setlength{\parindent}{0pt}
\parskip=8pt
\linespread{1.05} % Change line spacing here, Palatino benefits from a slight increase by default

\makeatletter
\renewcommand\@biblabel[1]{\textbf{#1.}} % Change the square brackets for each bibliography item from '[1]' to '1.'
\renewcommand{\@listI}{\itemsep=0pt} % Reduce the space between items in the itemize and enumerate environments and the bibliography
\newcommand{\imagen}[2]{\begin{center} \includegraphics[width=90mm]{#1} \\#2 \end{center}}

\renewcommand{\maketitle}{ % Customize the title - do not edit title and author name here, see the TITLE block below
\begin{flushright} % Right align
{\LARGE\@title} % Increase the font size of the title

\vspace{50pt} % Some vertical space between the title and author name

{\large\@author} % Author name
\\\@date % Date

\vspace{40pt} % Some vertical space between the author block and abstract
\end{flushright}
}


%Basado en: http://en.wikibooks.org/wiki/LaTeX/Theorems
\usepackage{amsthm}
\newtheorem*{mydef}{Definición}
\newtheorem{mydefn}{Definición}
\newtheorem{theorem}{Teorema}
\everymath{\displaystyle} % Displaystyle por defecto

%----------------------------------------------------------------------------------------
%	TITLE
%----------------------------------------------------------------------------------------

\title{\textbf{Práctica 4}\\ % Title
Backtracking y Branch \& Bound} % Subtitle

\author{\textsc{Óscar Bermúdez,\\Francisco David Charte,\\Ignacio Cordón,\\José Carlos Entrena,\\Mario Román} % Author
\\{\textit{Universidad de Granada}}} % Institution

\date{\today} % Date

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title section

\renewcommand{\abstractname}{Resumen} % Uncomment to change the name of the abstract to something else
\begin{abstract}
\end{abstract}
{\parskip=2pt
\tableofcontents
}
\pagebreak


\section{El problema de la mochila}

\subsection{Enunciado}
El problema de la mochila es un problema de maximización, en el que tenemos un contenedor con un tamaño 
fijo $M$ y un conjunto de $n$ elementos que queremos almacenar en nuestro contenedor. Dichos elementos tendrán un peso $\omega_i$
determinado, y obtendremos un cierto beneficio $b_i$ por cada objeto almacenado.

Nuestro objetivo es maximizar la suma de beneficios, $\sum_{i=1}^{n} b_i\delta_i$, (siendo $\delta_i = 1$ si el i-ésimo objeto está en la mochila, 0 en caso contrario) con la restricción de que la mochila solo puede llevar un peso máximo, determinado por su tamaño: $\sum_{i=1}^{n} \omega_i\delta_i \leq M$.

  
    \subsection{Backtracking}
Representamos una mochila como un vector de datos booleanos, $\delta$, de tamaño $n$. Esto implica que nuestro espacio de soluciones tendrá un tamaño de $2^n$.

La función de poda toma un vector $\delta = (\delta_1, \dots, \delta_n)$ y devuelve falso en caso de que $\sum_{i=1}^{n} \omega_i\delta_i > M$, asegurando así que solo se van considerando en el proceso candidatas a solución.


	\subsubsection{Algoritmo}
Nuestro algoritmo es de tipo iterativo, por lo que usa una cola en la que almacenamos las mochilas que vamos procesando. La poda se produce cuando al añadir un objeto, la mochila resultante supera el peso límite, en cuyo caso esta no es añadida a la cola de candidatas. Cuando encontremos una mochila completa, se compara con la solución actual, y se sustituye en caso de mejorarla. 

\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	$M$, límite de peso de la mochila \\
        	$\omega$, vector de pesos de objetos\\
        	$B$, vector de beneficios de objetos\\\
     	\STATE{\texttt{$n$ = \#pesos}}
	\STATE{\texttt{solución = [false,\dots,false]}}\\\
     	\STATE{Creamos una cola \texttt{posibles\_mochilas}}
     	\STATE{\texttt{posibles\_mochilas.push([])}}
     	
     	\WHILE{\texttt{posibles\_mochilas}$\neq \emptyset$}
	  \STATE{\texttt{actual = posibles\_mochilas.pop()}}
	  \IF{\texttt{\#actual == $n$}}
	    \IF{beneficio(\texttt{actual}) >\ beneficio(\texttt{solución})}
	      \STATE{\texttt{solución = actual}}
	    \ENDIF
	  \ELSE
	    \STATE{\texttt{con\_nuevo = sin\_nuevo = actual}
	    \STATE{\texttt{con\_nuevo.push\_back(true)}}
	    \STATE{\texttt{sin\_nuevo.push\_back(false)}}}
	    \STATE{\texttt{nuevo\_peso = }peso(\texttt{con\_nuevo})}
	    \IF{\texttt{nuevo\_peso} $\leq M$}
	    \STATE{(\textit{Acotación: no analizamos el caso si \texttt{nuevo\_peso} > $M$})}
	      \STATE{\texttt{posibles\_mochilas.push(con\_nuevo)}}
	    \ENDIF
	    \STATE{\texttt{posibles\_mochilas.push(sin\_nuevo)}}
	  \ENDIF
     	\ENDWHILE
     \RETURN{\texttt{solución}}
	\end{algorithmic}
    \caption{Algoritmo backtracking para el problema de la mochila}
    \label{Back-Mochila}
\end{algorithm}

En el algoritmo, \textit{beneficio} representa el valor de la suma de beneficios de un vector de booleanos $\delta$, $\sum_{i=1}^{n}b_i\delta_i$; y \textit{peso} representa la suma de pesos del vector $\delta$, $\sum_{i=1}^{n}\omega_i\delta_i$.



  \subsection{Branch \& Bound}
  
  Para la versión Branch \& Bound del algoritmo, usamos la misma representación para la solución, un vector de booleanos, y por tanto tenemos el mismo espacio de soluciones.
  
  En este caso, un nodo intermedio será del tipo $(\delta_1, \dots, \delta_k)$, y sus hijos serán $(\delta_1, \dots, \delta_k, 1)$ y $(\delta_1, \dots, \delta_k, 0)$.
  
  Se realiza un cálculo del máximo beneficio a partir de un nodo intermedio $(\delta_1, \dots, \delta_k)$. Para hallar esta cota, tomamos el peso que queda por llenar y le añadimos el peso de los objetos que tengan la mejor proporción \textit{beneficio}/\textit{peso}, hasta completar la capacidad de la mochila, y comparamos el beneficio asociado a estos objetos con la mejor solución obtenida hasta ahora.
  
	\subsubsection{Algoritmo}


\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	$M$, límite de peso de la mochila \\
         	$\omega$, vector de pesos de objetos\\
          	$B$, vector de beneficios de objetos\\\
     	\STATE{\texttt{$n$ = \#pesos}}
     		\STATE{\texttt{solución = [false,\dots,false]}}\\\
     	     	\STATE{Creamos una cola \texttt{posibles\_mochilas}}
     	     	\STATE{\texttt{posibles\_mochilas.push([])}}
     	     	
     	     	\WHILE{\texttt{posibles\_mochilas}$\neq \emptyset$}
     		  \STATE{\texttt{actual = posibles\_mochilas.pop()}}
     		  \IF{\texttt{\#actual == $n$}}
     		    \IF{beneficio(\texttt{actual}) >\ beneficio(\texttt{solución})}
     		      \STATE{\texttt{solución = actual}}
     		    \ENDIF
     		  \ELSE
     		    \STATE{\texttt{con\_nuevo = sin\_nuevo = actual}
     		    \STATE{\texttt{con\_nuevo.push\_back(true)}}
     		    \STATE{\texttt{sin\_nuevo.push\_back(false)}}}
     		    \STATE{\texttt{nuevo\_peso = }peso(\texttt{con\_nuevo})}
     		    \IF{\texttt{nuevo\_peso} $\leq M$}
     		    \STATE{(\textit{Acotación: no analizamos el caso si \texttt{nuevo\_peso} > $M$})}
     		      \STATE{\texttt{posibles\_mochilas.push(con\_nuevo)}}
	    \ENDIF
	    \IF{beneficio(\texttt{solución}) <\ beneficio(\texttt{sin\_nuevo}) + calculaCota(\texttt{sin\_nuevo})}
	      \STATE{\texttt{posibles\_mochilas.push(sin\_nuevo)}}
	    \ENDIF
	  \ENDIF
     	\ENDWHILE
     	\RETURN{\texttt{solución}}
     	
	\end{algorithmic}
    \caption{Algoritmo Branch \& Bound para el problema de la mochila}
    \label{BBound-Mochila}
\end{algorithm}


\section{Traveling Salesman Problem}
  \subsection{Enunciado}
    Dada una lista $S$ de $n$ ciudades, representadas como puntos en el plano:
    \begin{equation}
      S = [(x_0,y_0), (x_1,y_1), \dots (x_{n-1},y_{n-1})] \subset \mathbb{R}^2
    \end{equation}
    Y definiendo la longitud de recorrer una lista como la suma de las distancias de cada ciudad a la siguiente:
    \begin{equation}
     long(S) = \sum_{i \in \mathbb{Z}_n} dist((x_i,y_i), (x_{i+1}, y_{i+1})) = \sum_{i \in \mathbb{Z}_n} \sqrt{(x_i-x_{i+1})^2 + (y_i-y_{i+1})^2}
    \end{equation}
    El objetivo es encontrar la permutación de la lista $\sigma : \mathbb{Z}_n \leftrightarrow \mathbb{Z}_n$, verificando que su longitud sea mínima:
    \begin{equation}
     long(\sigma(S)) = long([(x_{\sigma(1)},y_{\sigma(1)}), (x_{\sigma(2)},y_{\sigma(2)}), \dots, (x_{\sigma(n)},y_{\sigma(n)})])
    \end{equation}
    
  \subsection{Backtracking}
  
  
  Utilizaremos un vector de enteros para representar una solución, donde almacenaremos los índices de las ciudades que se van recorriendo en la ruta. Como únicamente podemos pasar una vez por cada ciudad, el espacio de soluciones tendrá un tamaño de $n!$
  
  
    \subsubsection{Algoritmo}
      Para aplicar backtracking al problema del TSP, utilizamos un algoritmo recursivo, el cual recibe la lista de 
      ciudades del problema, la ruta con las ciudades que llevamos hasta el momento, su coste, y el índice de la 
      última ciudad añadida. Calcularemos todas las ramificaciones posibles de la ruta actual, y tomaremos la mejor 
      de estas, comparando el coste de cada rama con el coste de la mejor solución hasta el momento.
      
  \begin{algorithm}[H]
  	\begin{algorithmic}[1]
  		\REQUIRE \ \\
          \texttt{ciudades}, lista con todas las ciudades \\
          \texttt{ruta}, ruta con algunas ciudades \\
          \texttt{coste\_actual}, coste de la ruta pasada \\
          \texttt{índice}, índice de la ciudad a partir de la cual tiene que permutar. \\\

		\STATE{\texttt{mejor\_coste = $\infty$}}

        \IF{\texttt{indice == \#ciudades}}
          \STATE{\texttt{coste\_actual += distancia(ruta[$n$-1], ruta[0])}}

	      \IF{\texttt{coste\_actual <\ mejor\_coste}}
	        \STATE{\texttt{mejor\_coste = coste\_actual\\
	        mejor\_ruta = ruta}}
	      \ENDIF
	    \ELSE
	      \FOR{\texttt{i} = índice hasta \texttt{\#ciudades}:}
	        \STATE{Producimos una permutación:\\
	        \texttt{intercambia(ruta[i], ruta[indice])\\
	        coste\_actual += distancia(ruta[indice-1], ruta[indice])}}
	        \STATE{Llamamos recursivamente a la función:\\
	        \texttt{TSP(ciudades, ruta, coste\_actual, indice+1)}}
	        \STATE{Deshacemos el cambio:\\ 
	        \texttt{coste\_actual --= distancia(ruta[indice - 1], ruta[indice])\\
	        intercambiar(ruta[indice], ruta[i])}}
	      \ENDFOR
	    \ENDIF
	    \RETURN{\texttt{ruta}}
  	\end{algorithmic}
      \caption{Algoritmo Branch \& Bound para el TSP}
      \label{Back-TSP}
  \end{algorithm}
  
 
  \subsection{Branch \& Bound}
  \subsubsection{Algoritmo}
  
  Para la ramificación y poda de este problema, utilizaremos una técnica basada en 2-OPT para desechar permutaciones: Si al añadir una nueva ciudad, la ruta resultante contiene algún cruce de caminos, es mejorable por 2-OPT y por tanto no es óptima, luego podemos pasar al siguiente candidato sin tener en cuenta las soluciones derivadas de la que hemos calculado.  
  
    \begin{algorithm}[H]
    	\begin{algorithmic}[1]
		\REQUIRE \ \\
          \texttt{ciudades}, lista con todas las ciudades \\
          \texttt{ruta}, ruta con algunas ciudades \\
          \texttt{coste\_actual}, coste de la ruta pasada \\
          \texttt{índice}, índice de la ciudad a partir de la cual tiene que permutar. \\\

		\STATE{\texttt{mejor\_coste = $\infty$}}

        \IF{\texttt{indice == \#ciudades}}
          \STATE{\texttt{coste\_actual += distancia(ruta[$n$-1], ruta[0])}}

	      \IF{\texttt{coste\_actual < mejor\_coste}}
	        \STATE{\texttt{mejor\_coste = coste\_actual\\
	        mejor\_ruta = ruta}}
	      \ENDIF
	    \ELSIF{\texttt{coste\_actual > mejor\_coste}}
	      \RETURN $\emptyset$
	    \ELSE
	      \FOR{\texttt{i} = indice hasta \texttt{\#ciudades}:}
	        \STATE{\texttt{Buscamos un cruce de caminos. En cuyo caso, lo desechamos porque no puede ser el óptimo.}}
	        \STATE{\texttt{Producimos una permutación:\\
	        intercambiar(ruta[i], ruta[indice])\\
	        coste\_actual += distancia(ruta[indice-1], ruta[indice])}}
	        \STATE{\texttt{TSP(ciudades, ruta, coste\_actual, indice+1)}}
	        \STATE{\texttt{Deshacemos el cambio:\\ coste\_actual --= distancia(ruta[indice - 1], ruta[indice])\\
	        intercambiar(ruta[indice], ruta[i])}}
	        
	        
	      \ENDFOR
	    \ENDIF
	    \RETURN{\texttt{ruta}}
    	\end{algorithmic}
        \caption{Algoritmo Branch \& Bound para el TSP}
        \label{BBound-TSP}
    \end{algorithm}

\section{Planificación en multiprocesadores}
  \subsection{Enunciado}
  Tenemos un conjunto de $n$ tareas con un tiempo de ejecución $t_i$ asociado a cada una, existiendo una relación de precedencia
  entre algunas tareas, que hace que tengan que ejecutarse unas antes que otras. Nuestro objetivo es obtener la asignación de 
  tareas que, manteniendo las relaciones de dependencia, resulte en un tiempo de ejecución mínimo. 
  
  
  \subsection{Backtracking}
  
  \subsection{Branch \& Bound}

\section{3-Dimensional Matching}
  \subsection{Enunciado}
    Sean $X$,$Y$,$Z$ tres conjuntos finitos y sea $T \subset X \times Y \times Z$, subconjunto de tripletas válidas.
    Una asignación válida $M$ es un subconjunto de elementos disjuntos de $T$. Es decir, $M \subset T$ tal que:
    \begin{equation}
     \forall (x_1,y_1,z_1), (x_2,y_2,z_2) \in M : \quad (x_1 \neq x_2) \vee (y_1 \neq y_2) \vee (z_1 \neq z_2)
    \end{equation} 
    Buscamos la asignación válida de mayor cardinal, es decir la $M$ asignación válida maximizando $|M|$.
    
  \subsection{Backtracking}
  En este algoritmo consideraremos todas las asignaciones posibles y nos quedaremos con la asignación que tenga mayor cardinal. Para ello, consideraremos todas las aristas e iremos comprobando para cada una si es posible añadirla. De ser así, distinguiremos dos casos: La arista puede pertenecer o no a la solución. Sobre estos dos casos aplicaremos el mismo algoritmo. Cuando no quede ninguna arista que pueda ser añadida, compararemos los tamaños de la solución obtenida y la mejor solución hasta el momento, actualizando la mejor solución si la actual la mejorase. 
  
  Representaremos la solución como un vector de booleanos, que nos indican si la arista asociada al índice se encuentra o no en la solución. Como cada arista tiene la opción de estar o no estar en la solución, la dimensión del espacio de soluciones es de $2^n$, siendo $n$ el número de aristas. 
  
  \subsection{Branch \& Bound}
  
    Para la versión Branch \& Bound del algoritmo, usaremos la misma representación para la solución, un vector de booleanos, por lo que tendremos el mismo espacio de soluciones.
    
    Como función de poda sobre una solución parcial, consideraremos la satisfacción que obtendríamos con todas las aristas restantes como cota máxima de la satisfacción posible a obtener. Si la satisfacción máxima de la parte restante sumada con la satisfacción de la solución parcial es menor que la satisfacción de la mejor solución hasta el momento, podemos descartar la solución parcial y obviar todas las ramas derivadas. 
    
	\subsubsection{Algoritmo}
      \begin{algorithm}[H]
      	\begin{algorithmic}[1]
  		\REQUIRE \ \\
        	\texttt{aristas} \\
     	\STATE{\texttt{$n$ = \#aristas}}
     	\STATE{\texttt{solución = [[false,\dots,false],[false,\dots,false],[false,\dots,false]]}}\\\
     	\STATE{Creamos una cola \texttt{posibles\_particiones}}
     	\STATE{\texttt{posibles\_particiones.push([])}}
     	
     	\WHILE{\texttt{posibles\_particiones}$\neq \emptyset$}
		  \STATE{\texttt{actual = posibles\_particiones.pop()}}
		  \STATE{\texttt{indice = \#actual.aristas}}
		  \IF{\texttt{indice == $n$}}
		    \IF{valor(\texttt{actual}) >\ valor(\texttt{solución})}
		      \STATE{\texttt{solución = actual}}
		    \ENDIF
		  \ELSE
	        \STATE{\texttt{con\_nueva = sin\_nueva = actual}
	        \STATE{\texttt{con\_nueva.push\_back(true)}}
	        \STATE{\texttt{sin\_nueva.push\_back(false)}}}
	        
	        \STATE{\texttt{posibles\_mochilas.push(sin\_nueva)}}
	        \IF{Se puede añadir}
	        \STATE{\texttt{posibles\_mochilas.push(con\_nueva)}}
	        \ENDIF
	      \ENDIF
 		\ENDWHILE
     \RETURN{\texttt{solución}}
      	\end{algorithmic}
          \caption{Algoritmo Backtracking para el 3D Matching}
          \label{Back-3DMatch}
      \end{algorithm}

  \subsection{Branch \& Bound}
    \begin{algorithm}[H]
    	\begin{algorithmic}[1]
		\REQUIRE 
    	\end{algorithmic}
        \caption{Algoritmo Branch \& Bound para el 3D Matching}
        \label{BBound-3DMatch}
    \end{algorithm}
  

\section{El problema de la asignación cuadrática (QAP)}
  \subsection{Enunciado}
    Dado un conjunto de $n$ instalaciones con un flujo de transporte y un coste asociado entre ellas, y dadas $n$ posibles 
    localizaciones, el problema consiste en buscar la localización más adecuada para cada instalación, de forma que el 
    coste total del transporte entre instalaciones sea el mínimo posible. 

  \subsection{Backtracking}
  \subsection{Branch \& Bound}


\section{Implementaciones}
  \subsection{El problema de la mochila}
        Versión en C++:
        
        \small
  	\texttt{\input{mochila.tex}}
        \normalsize
        
        Versión en Haskell:
        
        \small
  	\texttt{\input{backtracking.tex}}
        \normalsize
        
  \subsection{Travelling Salesman Problem}
        \small
  	\texttt{\input{tsp.tex}}
        \normalsize
  \subsection{Planificación en multiprocesadores}
        \small
  	\texttt{\input{planificacion.tex}}
        \normalsize
  \subsection{3-Dimensional Matching}
        \small
  	\texttt{\input{3matching.tex}}
        \normalsize
  \subsection{El problema de la asignación cuadrática (QAP)}
        \small
  	%\texttt{\input{terminales.tex}}
        \normalsize

    
\end{document}