%%%%
% Modificación de una plantilla de Latex para adaptarla al castellano.
%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Thin Sectioned Essay
% LaTeX Template
% Version 1.0 (3/8/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original Author:
% Nicolas Diaz (nsdiaz@uc.cl) with extensive modifications by:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper, 11pt]{article} % Font size (can be 10pt, 11pt or 12pt) and paper size (remove a4paper for US letter paper)

\usepackage[protrusion=true,expansion=true]{microtype} % Better typography
\usepackage{graphicx} % Required for including pictures
\usepackage[usenames,dvipsnames]{color} % Coloring code
\usepackage{wrapfig} % Allows in-line images
\usepackage[utf8]{inputenc}

% Imágenes
\usepackage{graphicx} 

\usepackage{amsmath}
% para importar svg
%\usepackage[generate=all]{svgfig}

% sudo apt-get install texlive-lang-spanish
\usepackage[spanish]{babel} % English language/hyphenation
\selectlanguage{spanish}
% Hay que pelearse con babel-spanish para el alineamiento del punto decimal
\decimalpoint
\usepackage{dcolumn}
\newcolumntype{d}[1]{D{.}{\esperiod}{#1}}
\makeatletter
\addto\shorthandsspanish{\let\esperiod\es@period@code}
\makeatother

\usepackage{longtable}
\usepackage{tabu}
\usepackage{supertabular}

\usepackage{multicol}
\newsavebox\ltmcbox

% Para algoritmos
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsthm}
\input{spanishAlgorithmic.tex}

% Para matrices
\usepackage{amsmath}

% Símbolos matemáticos
\usepackage{amssymb}
\let\oldemptyset\emptyset
\let\emptyset\varnothing

\usepackage[section]{placeins} % Para gráficas en su sección.
\usepackage{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Required for accented characters
\newenvironment{allintypewriter}{\ttfamily}{\par}
\setlength{\parindent}{0pt}
\parskip=8pt
\linespread{1.05} % Change line spacing here, Palatino benefits from a slight increase by default

\makeatletter
\renewcommand\@biblabel[1]{\textbf{#1.}} % Change the square brackets for each bibliography item from '[1]' to '1.'
\renewcommand{\@listI}{\itemsep=0pt} % Reduce the space between items in the itemize and enumerate environments and the bibliography
\newcommand{\imagen}[2]{\begin{center} \includegraphics[width=90mm]{#1} \\#2 \end{center}}

\renewcommand{\maketitle}{ % Customize the title - do not edit title and author name here, see the TITLE block below
\begin{flushright} % Right align
{\LARGE\@title} % Increase the font size of the title

\vspace{50pt} % Some vertical space between the title and author name

{\large\@author} % Author name
\\\@date % Date

\vspace{40pt} % Some vertical space between the author block and abstract
\end{flushright}
}


%Basado en: http://en.wikibooks.org/wiki/LaTeX/Theorems
\usepackage{amsthm}
\newtheorem*{mydef}{Definición}
\newtheorem{mydefn}{Definición}
\newtheorem{theorem}{Teorema}
\everymath{\displaystyle} % Displaystyle por defecto

%----------------------------------------------------------------------------------------
%	TITLE
%----------------------------------------------------------------------------------------

\title{\textbf{Práctica 4}\\ % Title
Backtracking y Branch \& Bound} % Subtitle

\author{\textsc{Óscar Bermúdez,\\Francisco David Charte,\\Ignacio Cordón,\\José Carlos Entrena,\\Mario Román} % Author
\\{\textit{Universidad de Granada}}} % Institution

\date{\today} % Date

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title section

\renewcommand{\abstractname}{Resumen} % Uncomment to change the name of the abstract to something else
\begin{abstract}
\end{abstract}
{\parskip=2pt
\tableofcontents
}
\pagebreak


\section{El problema de la mochila}

\subsection{Enunciado}
El problema de la mochila es un problema de maximización, en el que tenemos un contenedor con un tamaño 
fijo $M$ y un conjunto de $n$ elementos que queremos almacenar en nuestro contenedor. Dichos elementos tendrán un peso $\omega_i$
determinado, y obtendremos un cierto beneficio $b_i$ por cada objeto almacenado.

Nuestro objetivo es maximizar la suma de beneficios, $\sum_{i=1}^{n} b_i\delta_i$, (siendo $\delta_i = 1$ si el i-ésimo objeto está en la mochila, 0 en caso contrario) con la restricción de que la mochila solo puede llevar un peso máximo, determinado por su tamaño: $\sum_{i=1}^{n} \omega_i\delta_i \leq M$.

  
    \subsection{Backtracking}
Representamos una mochila como un vector de datos booleanos, $\delta$, de tamaño $n$. Esto implica que nuestro espacio de soluciones tendrá un tamaño de $2^n$.

La función de poda toma un vector $\delta = (\delta_1, \dots, \delta_n)$ y devuelve falso en caso de que $\sum_{i=1}^{n} \omega_i\delta_i > M$, asegurando así que solo se van considerando en el proceso candidatas a solución.


	\subsubsection{Algoritmo}
Nuestro algoritmo es de tipo iterativo, por lo que usa una cola en la que almacenamos las mochilas que vamos procesando. La poda se produce cuando al añadir un objeto, la mochila resultante supera el peso límite, en cuyo caso esta no es añadida a la cola de candidatas. Cuando encontremos una mochila completa, se compara con la solución actual, y se sustituye en caso de mejorarla. 

\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	$M$, límite de peso de la mochila \\
        	$\omega$, vector de pesos de objetos\\
        	$B$, vector de beneficios de objetos\\\
     	\STATE{\texttt{$n$ = \#pesos}}
	\STATE{\texttt{solución = [false,\dots,false]}}\\\
     	\STATE{Creamos una cola \texttt{posibles\_mochilas}}
     	\STATE{\texttt{posibles\_mochilas.push([])}}
     	
     	\WHILE{\texttt{posibles\_mochilas}$\neq \emptyset$}
	  \STATE{\texttt{actual = posibles\_mochilas.pop()}}
	  \IF{\texttt{\#actual == $n$}}
	    \IF{beneficio(\texttt{actual}) >\ beneficio(\texttt{solución})}
	      \STATE{\texttt{solución = actual}}
	    \ENDIF
	  \ELSE
	    \STATE{\texttt{con\_nuevo = sin\_nuevo = actual}
	    \STATE{\texttt{con\_nuevo.push\_back(true)}}
	    \STATE{\texttt{sin\_nuevo.push\_back(false)}}}
	    \STATE{\texttt{nuevo\_peso = }peso(\texttt{con\_nuevo})}
	    \IF{\texttt{nuevo\_peso} $\leq M$}
	    \STATE{(\textit{Acotación: no analizamos el caso si \texttt{nuevo\_peso} > $M$})}
	      \STATE{\texttt{posibles\_mochilas.push(con\_nuevo)}}
	    \ENDIF
	    \STATE{\texttt{posibles\_mochilas.push(sin\_nuevo)}}
	  \ENDIF
     	\ENDWHILE
     \RETURN{\texttt{solución}}
	\end{algorithmic}
    \caption{Algoritmo backtracking para el problema de la mochila}
    \label{Back-Mochila}
\end{algorithm}

En el algoritmo, \textit{beneficio} representa el valor de la suma de beneficios de un vector de booleanos $\delta$, $\sum_{i=1}^{n}b_i\delta_i$; y \textit{peso} representa la suma de pesos del vector $\delta$, $\sum_{i=1}^{n}\omega_i\delta_i$.



  \subsection{Branch \& Bound}
	\subsubsection{Algoritmo}


\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	$M$, límite de peso de la mochila \\
         	$\omega$, vector de pesos de objetos\\
          	$B$, vector de beneficios de objetos\\\
     	\STATE{\texttt{$n$ = \#pesos}}
     		\STATE{\texttt{solución = [false,\dots,false]}}\\\
     	     	\STATE{Creamos una cola \texttt{posibles\_mochilas}}
     	     	\STATE{\texttt{posibles\_mochilas.push([])}}
     	     	
     	     	\WHILE{\texttt{posibles\_mochilas}$\neq \emptyset$}
     		  \STATE{\texttt{actual = posibles\_mochilas.pop()}}
     		  \IF{\texttt{\#actual == $n$}}
     		    \IF{beneficio(\texttt{actual}) >\ beneficio(\texttt{solución})}
     		      \STATE{\texttt{solución = actual}}
     		    \ENDIF
     		  \ELSE
     		    \STATE{\texttt{con\_nuevo = sin\_nuevo = actual}
     		    \STATE{\texttt{con\_nuevo.push\_back(true)}}
     		    \STATE{\texttt{sin\_nuevo.push\_back(false)}}}
     		    \STATE{\texttt{nuevo\_peso = }peso(\texttt{con\_nuevo})}
     		    \IF{\texttt{nuevo\_peso} $\leq M$}
     		    \STATE{(\textit{Acotación: no analizamos el caso si \texttt{nuevo\_peso} > $M$})}
     		      \STATE{\texttt{posibles\_mochilas.push(con\_nuevo)}}
	    \ENDIF
	    \IF{beneficio(\texttt{solución}) <\ beneficio(\texttt{sin\_nuevo}) + calculaCota(\texttt{sin\_nuevo})}
	      \STATE{\texttt{posibles\_mochilas.push(sin\_nuevo)}}
	    \ENDIF
	  \ENDIF
     	\ENDWHILE
     	\RETURN{\texttt{solución}}
     	
	\end{algorithmic}
    \caption{Algoritmo Branch \& Bound para el problema de la mochila}
    \label{BBound-Mochila}
\end{algorithm}


\section{Traveling Salesman Problem}
  \subsection{Enunciado}
    Dada una lista $S$ de $n$ ciudades, representadas como puntos en el plano:
    \begin{equation}
      S = [(x_0,y_0), (x_1,y_1), \dots (x_{n-1},y_{n-1})] \subset \mathbb{R}^2
    \end{equation}
    Y definiendo la longitud de recorrer una lista como la suma de las distancias de cada ciudad a la siguiente:
    \begin{equation}
     long(S) = \sum_{i \in \mathbb{Z}_n} dist((x_i,y_i), (x_{i+1}, y_{i+1})) = \sum_{i \in \mathbb{Z}_n} \sqrt{(x_i-x_{i+1})^2 + (y_i-y_{i+1})^2}
    \end{equation}
    El objetivo es encontrar la permutación de la lista $\sigma : \mathbb{Z}_n \leftrightarrow \mathbb{Z}_n$, verificando que su longitud sea mínima:
    \begin{equation}
     long(\sigma(S)) = long([(x_{\sigma(1)},y_{\sigma(1)}), (x_{\sigma(2)},y_{\sigma(2)}), \dots, (x_{\sigma(n)},y_{\sigma(n)})])
    \end{equation}
    
  \subsection{Backtracking}
  \subsubsection{Algoritmo}
  Para aplicar backtracking al problema del TSP, utilizamos un algoritmo recursivo, el cual recibe la lista de ciudades del problema, la ruta con las ciudades que llevamos hasta el momento, su coste, y el índice de la última ciudad añadida. Calcularemos todas las ramificaciones posibles de la ruta actual, y tomaremos la mejor de estas, comparando el coste de cada rama con el coste de la mejor solución hasta el momento. Además, utilizaremos una técnica 2-OPT para desechar permutaciones: Si la ruta contiene algún cruce de caminos, es mejorable por 2-OPT y por tanto no es óptima. 
  
  \begin{algorithm}[H]
  	\begin{algorithmic}[1]
  		\REQUIRE \ \\
          \texttt{ciudades}, lista con todas las ciudades \\
          \texttt{ruta}, ruta con algunas ciudades \\
          \texttt{coste\_actual}, coste de la ruta pasada \\
          \texttt{índice}, índice de la ciudad a partir de la cual tiene que permutar. \\\

		\STATE{\texttt{mejor\_coste = $\infty$}}

        \IF{\texttt{indice == \#ciudades}}
          \STATE{\texttt{coste\_actual += distancia(ruta[$n$-1], ruta[0])}}

	      \IF{\texttt{coste\_actual <\ mejor\_coste}}
	        \STATE{\texttt{mejor\_coste = coste\_actual\\
	        mejor\_ruta = ruta}}
	      \ENDIF
	    \ELSE
	      \FOR{\texttt{i} = índice hasta \texttt{\#ciudades}:}
	        \STATE{Producimos una permutación:\\
	        \texttt{intercambia(ruta[i], ruta[indice])\\
	        coste\_actual += distancia(ruta[indice-1], ruta[indice])}}
	        \STATE{Llamamos recursivamente a la función:\\
	        \texttt{TSP(ciudades, ruta, coste\_actual, indice+1)}}
	        \STATE{Deshacemos el cambio:\\ 
	        \texttt{coste\_actual --= distancia(ruta[indice - 1], ruta[indice])\\
	        intercambiar(ruta[indice], ruta[i])}}
	        
	        
	      \ENDFOR
	    \ENDIF
	    \RETURN{\texttt{ruta}}
  	\end{algorithmic}
      \caption{Algoritmo Branch \& Bound para el TSP}
      \label{Back-TSP}
  \end{algorithm}
  \subsection{Branch \& Bound}
    \begin{algorithm}[H]
    	\begin{algorithmic}[1]
		\REQUIRE \ \\
          \texttt{ciudades}, lista con todas las ciudades \\
          \texttt{ruta}, ruta con algunas ciudades \\
          \texttt{coste\_actual}, coste de la ruta pasada \\
          \texttt{índice}, índice de la ciudad a partir de la cual tiene que permutar. \\\

		\STATE{\texttt{mejor\_coste = $\infty$}}

        \IF{\texttt{indice == \#ciudades}}
          \STATE{\texttt{coste\_actual += distancia(ruta[$n$-1], ruta[0])}}

	      \IF{\texttt{coste\_actual < mejor\_coste}}
	        \STATE{\texttt{mejor\_coste = coste\_actual\\
	        mejor\_ruta = ruta}}
	      \ENDIF
	    \ELSIF{\texttt{coste\_actual > mejor\_coste}}
	      \RETURN $\emptyset$
	    \ELSE
	      \FOR{\texttt{i} = indice hasta \texttt{\#ciudades}:}
	        \STATE{\texttt{Buscamos un cruce de caminos. En cuyo caso, lo desechamos porque no puede ser el óptimo.}}
	        \STATE{\texttt{Producimos una permutación:\\
	        intercambiar(ruta[i], ruta[indice])\\
	        coste\_actual += distancia(ruta[indice-1], ruta[indice])}}
	        \STATE{\texttt{TSP(ciudades, ruta, coste\_actual, indice+1)}}
	        \STATE{\texttt{Deshacemos el cambio:\\ coste\_actual --= distancia(ruta[indice - 1], ruta[indice])\\
	        intercambiar(ruta[indice], ruta[i])}}
	        
	        
	      \ENDFOR
	    \ENDIF
	    \RETURN{\texttt{ruta}}
    	\end{algorithmic}
        \caption{Algoritmo Branch \& Bound para el TSP}
        \label{BBound-TSP}
    \end{algorithm}

\section{Planificación en multiprocesadores}
  \subsection{Enunciado}
  Tenemos un conjunto de $n$ tareas con un tiempo de ejecución $t_i$ asociado a cada una, existiendo una relación de precedencia
  entre algunas tareas, que hace que tengan que ejecutarse unas antes que otras. Nuestro objetivo es obtener la asignación de tareas que, manteniendo las relaciones de dependencia, resulte en un tiempo de ejecución mínimo. 
  
  
  \subsection{Backtracking}
  \subsection{Branch \& Bound}

\section{3-Dimensional Matching}
  \subsection{Backtracking}
  \subsection{Branch \& Bound}

\section{El problema de la asignación cuadrática (QAP)}
  \subsection{Enunciado}
   Dado un conjunto de $n$ instalaciones con un flujo de transporte y un coste asociado entre ellas, y dadas $n$ posibles localizaciones, el problema consiste en buscar la localización más adecuada para cada instalación, de forma que el coste total del transporte entre instalaciones sea el mínimo posible. 

  \subsection{Backtracking}
  \subsection{Branch \& Bound}


\section{Implementaciones}
  \subsection{El problema de la mochila}
        Versión en C++:
        
        \small
  	\texttt{\input{mochila.tex}}
        \normalsize
        
        Versión en Haskell:
        
        \small
  	\texttt{\input{backtracking.tex}}
        \normalsize
        
  \subsection{Travelling Salesman Problem}
        \small
  	\texttt{\input{tsp.tex}}
        \normalsize
  \subsection{Planificación en multiprocesadores}
        \small
  	\texttt{\input{planificacion.tex}}
        \normalsize
  \subsection{3-Dimensional Matching}
        \small
  	\texttt{\input{3matching.tex}}
        \normalsize
  \subsection{El problema de la asignación cuadrática (QAP)}
        \small
  	%\texttt{\input{terminales.tex}}
        \normalsize

    
\end{document}